<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>PCRE Performance Project</title>

  <style type="text/css">
    body {
      background-color: #707070;
      color: black;
      font-family: "garamond"
    }
    td.main {
      background-color: white;
      color: black;
      font-family: "garamond"
    }
	table.results {
	  background-color: #B0B0B0;
	}
	th {
	  background-color: #B0C4DE;
	}
	td.pattern {
	  background-color: #F0E68C;
	  text-align:left;
	}
	td.cpattern {
	  background-color: #40E0D0;
	  text-align:left;
	}
	td.time {
	  background-color: #E0FFFF;
	  text-align:right;
	}
	td.ratio {
	  background-color: #DEB887;
	  text-align:right;
	}
	td.separator {
	  /* background-color: #B0C4DE; */
	  background-color: #B0B0B0;
	}
	a {
	   font-weight:bold;
	}
  </style>
</head>

<body>

<center>
<table width="760" cellspacing=0 cellpadding=0>
<tr height=20><td width=20 class="main"></td><td width=720 class="main"></td><td width=20 class="main"></td></tr>
<tr><td width=20 class="main"></td><td width=720 class="main">

<h1><center><b>PCRE Performance Project</b></center></h1>

<h3>About</h3>

The aim of PCRE-sljit project is speeding up the pattern matching speed of
<a href="http://www.pcre.org/">Perl Compatible Regular Expressions</a> library
(<a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/">ftp download</a>).
The task is achieved by using <a href="https://github.com/zherczeg/sljit/">sljit</a>,
a just-in-time (JIT) compilation library to translate machine code from the internal
byte-code representation generated by <i>pcre_compile()</i>. PCRE-sljit offers similar
matching speed to DFA based engines (like <a href = "http://code.google.com/p/re2/">re2</a>)
on common patterns but still keep PERL compatibility (<a href = "regex_perf.html">see
here</a>).<br>
<br>
This work has been released as part of PCRE 8.20 and above. The JIT was improved a lot
in 8.32, and a new so called <b>native interface</b> was introduced. See the results.

<h3>About performance optimizations</h3>

<b>Always do profiling!</b> PCRE-JIT can only help you, if matching regular expressions
takes at least 4-5% of the total runtime. Otherwise you might not see any performance
increase (or you will see performance drops) due to the changes of the binary layout.
It is unfortunately less known, that inserting nops can increase or decrease the runtime
of any program by up to 3%, due the the CPU cache layout, branch prediction mechanisms,
etc. In artificial cases, the runtime change can be even bigger (&plusmn;50% for example).
When any function is modified, even if the change is small, it affects the entire binary
layout, since the entry offset of other functions will be changed as well (especially those,
which are placed after this function in the executable by the linker). Therefore when the
ratio of matching regular expressions is very low, you might experience a slight performance
drop when using PCRE-JIT.

<h3>Usage</h3>

Because of compatibility reasons the JIT compilation must be explicitly requested
by software. First of all PCRE must be compiled with <b>--enable-jit</b>. (Note:
JIT compiler availability can be checked runtime by passing <i>PCRE_CONFIG_JIT</i>
to <i>pcre_config()</i>.) The next step is performing the JIT compilation by passing
<i>PCRE_STUDY_JIT_COMPILE</i>, <i>PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE</i> or
<i>PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE</i> to <i>pcre_study()</i>. Regardless of
the success of JIT compilation, the returned extra data can be passed to <i>pcre_exec()</i>,
which use the machine code when approprite, or fallback to the interpreted code path
(Note: a few patterns are not supported by the JIT compiler). Passing <i>PCRE_INFO_JIT</i>
to <i>pcre_fullinfo()</i> can be used to check whether the JIT compilation is successful.
If the JIT compilation is succesful <i>pcre[16|32]_jit_exec</i> can be used to reach
even better performance. It is also mandatory to use <i>pcre_free_study()</i>
to free the machine code when the JIT compilation is succesful. Otherwise
<i>pcre_free_study()</i> is optional for compatibility reasons, but we suggest
to use it all the time.<br>
<br>
Detailed info about the JIT compiler can be found in <a href="http://www.manpagez.com/man/3/pcrejit/">
pcrejit.3</a>, which is part of the PCRE documentation. It is advisable to read the
"CONTROLLING THE JIT STACK" section there.

<h3>Motivation</h3>

<i>The importance of pattern matching has been significantly grown in the last decade.
The increased computation power allows running more complex regular expressions in
an acceptable time frame. However, this is not the only way to speed up regular
expressions. The developers of JavaScript engines realized that their just-in-time
compilation engines are able to considerably improve the runtime of pattern matching.
Thus, JIT based regular expression engines were developed like
<a href="http://blog.chromium.org/2009/02/irregexp-google-chromes-new-regexp.html">irregexp</a>
from Google and <a href="http://trac.webkit.org/browser/trunk/Source/JavaScriptCore/yarr">
YARR (Yet Another Regex Runtime)</a> from Apple. However, these engines are heavily tied
to their JavaScript engine (V8 from Google and JavaScriptCore from Apple), and other
software cannot benefit from this shiny new technology, until now. The aim of this
work is to extend a widely used regular expression library (PCRE) with a JIT compiler
engine, which can be easly adopted by any software already using PCRE.</i>

<h3>How does it work?</h3>

First, a regular expression is compiled into an internal representation by <i>pcre_compile()</i>.
The internal representation (usually called MIR - Middle Level Representation) is a sequence
of byte-codes. Each byte-code is basically a command, which tells the next step for the
interpreter inside <i>pcre_exec()</i>. The JIT compiler translates MIR to machine code
when the appropriate flags are passed to <i>pcre_study()</i>. The returned <i>pcre_extra data</i>
contains a pointer to a machine executable function if the machine code generation was successful.

<h3>Why is it faster?</h3>

JIT compilers totally eliminate the continual reparsing of MIR. Even if the MIR code is much
simpler than the original pattern string, the execution engine is full of <i>ifs</i> and
<i>switches</i>, and executing them consumes considerable time. The compiled machine
code only contains those machine instructions whose are absolutely necessary for this
particular pattern, and nothing more.<br>
<br>
This advantage is also a <b>limitation</b> since JIT compiler does not support the
changing of compile time flags. One such flag is the newline type (PCRE supports
many of them). PCRE allows overwriting the compile time newline flags when
<i>pcre_exec()</i> is called. This is not supported by the JIT compiler,
and the regular expression will be fallbacks to the interpreter.

<h3>Compile time overhead</h3>

Deciding when to use or not use JIT compiling is an important question. Since JIT is a heavyweight
optimization we should never forget about the compile time overhead. Thus, the total
runtime can be bigger if we use the compiled expression only once on a small input.<br>
<br>
The following values measured on an Intel 2.67GHz with GCC 4.4.5 in 64 bit mode<br>
Note: ns means nanosecond (10<sup>-9</sup>), and Int. means interpreter (<i>pcre_exec()</i>)<br>
<br>
<table class="results" width="100%" border="1">
<tr><th>Pattern</th><th>Compile time<br>(ns)</th><th>JIT compile time<br>(ns)</th><th>JIT compile /<br>compile time</th></tr>
<tr><td class="pattern">abc</td><td class="time">264</td><td class="time">7932</td><td class="ratio">30.05</td></tr>
<tr><td class="pattern">a+(b*)[c|d]??e+?</td><td class="time">925</td><td class="time">17186</td><td class="ratio">18.58</td></tr>
<tr><td class="pattern">\A.*\K[^a-z!]{8,}\Z</td><td class="time">925</td><td class="time">11501</td><td class="ratio">12.43</td></tr>
<tr><td class="pattern">\b((.)\w{3,}\2{0,3})$</td><td class="time">1057</td><td class="time">21747</td><td class="ratio">20.57</td></tr>
<tr><td class="pattern">(?P&lt;cap&gt;\p{N}+|(?(R)a|(?R)))\1</td><td class="time">1322</td><td class="time">30869</td><td class="ratio">23.35</td></tr>
<tr><td class="pattern">^(?![a-zA-Z]*?[[:alpha:]]++)\P{L&amp;}</td><td class="time">1520</td><td class="time">20425</td><td class="ratio">13.44</td></tr>
</table>

<h3>Results</h3>

The following patterns are searched on a <a href="http://www.gutenberg.org/files/3200/old/mtent12.zip">non-utf8 input</a>
and an <a href="http://www.gutenberg.org/cache/epub/23756/pg23756.txt">utf8 input</a>. The utf8 input was shorter
so it was repeated 4 times (with a simple <i>memcpy()</i>).<br>
<br>
The performace is measured on an Intel 2.67GHz with GCC 4.4.5 in both 32 and 64 bit mode. The unit of the
runtime values are milliseconds (ms) which is 10<sup>-3</sup> second. The PCRE library was compiled with
-O3 and -static compiler options to get the best performance form the compiler.<br>
<br>
<b>Description of the colums</b>
<ul>
<li><i>Pattern:</i> the pattern string. The light blue lines are caseless, the light yellow lines are caseful matches.</li>
<li><i>Int. (ms):</i> interpreter (normal pcre_exec(...)) runtime in milliseconds.</li>
<li><i>JIT (ms):</i> JIT compiled machine code runtime in milliseconds.</li>
<li><i>Runtime ratio:</i> Interpreter runtime / JIT runtime.</li>
<li><i>Runtime save %:</i> Runtime saved by the JIT compiler. Equals to 1 - (JIT runtime / Interpreter runtime)</li>
</ul>
<br>

<table class="results" width="100%" border="1">
<tr><th>Pattern</th><th>Int.<br>(ms)</th><th>JIT<br>(ms)</th><th>Runtime<br>ratio</th><th>Runtime<br>save %</th></tr>
<tr><td class="pattern">how to</td><td class="time">60</td><td class="time">40</td><td class="ratio">1.50</td><td class="ratio">33.3%</td></tr>
<tr><td class="pattern">^how to</td><td class="time">150</td><td class="time">20</td><td class="ratio">7.50</td><td class="ratio">86.7%</td></tr>
<tr><td class="pattern">how( to|ever)</td><td class="time">60</td><td class="time">30</td><td class="ratio">2.00</td><td class="ratio">50.0%</td></tr>
<tr><td class="cpattern">walk|get|she|make</td><td class="time">240</td><td class="time">70</td><td class="ratio">3.43</td><td class="ratio">70.8%</td></tr>
<tr><td class="pattern">[Ww]alk|[Gg]et|[Ss]he|[Mm]ake</td><td class="time">250</td><td class="time">90</td><td class="ratio">2.78</td><td class="ratio">64.0%</td></tr>
<tr><td class="pattern">(?:ba|lu|ro)+(?:r|ck)*</td><td class="time">210</td><td class="time">70</td><td class="ratio">3.00</td><td class="ratio">66.7%</td></tr>
<tr><td class="cpattern">(?:ba|lu|ro)+(r|ck)*</td><td class="time">210</td><td class="time">70</td><td class="ratio">3.00</td><td class="ratio">66.7%</td></tr>
<tr><td class="cpattern">\w+our\w*</td><td class="time">1680</td><td class="time">410</td><td class="ratio">4.10</td><td class="ratio">75.6%</td></tr>
<tr><td class="pattern">(?:^\w+$)|\b(\W)\1+\b</td><td class="time">1630</td><td class="time">310</td><td class="ratio">5.26</td><td class="ratio">81.0%</td></tr>
<tr><td class="cpattern">"[A-Z][a-z]*(?:(?:[,\s]|\R)(\s|\R)*[a-z]+){0,4}?[.!]"</td><td class="time">90</td><td class="time">40</td><td class="ratio">2.25</td><td class="ratio">55.6%</td></tr>
<tr><td class="pattern">\b(?:(?=\w+ro\w+)(?=\w+th\w+)\w+hr\w+)\b</td><td class="time">1200</td><td class="time">300</td><td class="ratio">4.00</td><td class="ratio">75.0%</td></tr>
<tr><td class="pattern">\b(?(?=\w+sh)\w+a|\w+uo)\w+\b</td><td class="time">1870</td><td class="time">370</td><td class="ratio">5.05</td><td class="ratio">80.2%</td></tr>
<tr><td class="cpattern">\b\WX{0,3}(?:(?:V?I{1,3})|V|IV|IX)\W\b</td><td class="time">820</td><td class="time">180</td><td class="ratio">4.56</td><td class="ratio">78.0%</td></tr>
<tr><td class="pattern">((\w)+?)\.\b(\s)*?\w</td><td class="time">4380</td><td class="time">540</td><td class="ratio">8.11</td><td class="ratio">87.7%</td></tr>
<tr><td class="pattern">(.{1,3})(\w*?\1)(?2)</td><td class="time">6060</td><td class="time">1530</td><td class="ratio">3.96</td><td class="ratio">74.8%</td></tr>
<tr><td class="pattern">-?-?-?-?-?-?-?-?-?-?-?-----------$</td><td class="time">600</td><td class="time">100</td><td class="ratio">6.00</td><td class="ratio">83.3%</td></tr>
<tr><td class="separator"></td><td class="separator"></td><td class="separator"></td><td class="separator"></td><td class="separator"></td></tr>
<tr><td class="pattern">Average:</td><td class="time">1219</td><td class="time">260</td><td class="ratio">4.16</td><td class="ratio">70.6%</td></tr>
</table>
<center><b>Non-utf8 input on a 32 bit x86 machine.</b></center>
<br>
<table class="results" width="100%" border="1">
<tr><th>Pattern</th><th>Int.<br>(ms)</th><th>JIT<br>(ms)</th><th>Runtime<br>ratio</th><th>Runtime<br>save %</th></tr>
<tr><td class="pattern">how to</td><td class="time">60</td><td class="time">40</td><td class="ratio">1.50</td><td class="ratio">33.3%</td></tr>
<tr><td class="pattern">^how to</td><td class="time">180</td><td class="time">40</td><td class="ratio">4.50</td><td class="ratio">77.8%</td></tr>
<tr><td class="pattern">how( to|ever)</td><td class="time">60</td><td class="time">20</td><td class="ratio">3.00</td><td class="ratio">66.7%</td></tr>
<tr><td class="cpattern">walk|get|she|make</td><td class="time">300</td><td class="time">80</td><td class="ratio">3.75</td><td class="ratio">73.3%</td></tr>
<tr><td class="pattern">[Ww]alk|[Gg]et|[Ss]he|[Mm]ake</td><td class="time">280</td><td class="time">100</td><td class="ratio">2.80</td><td class="ratio">64.3%</td></tr>
<tr><td class="pattern">(?:ba|lu|ro)+(?:r|ck)*</td><td class="time">220</td><td class="time">80</td><td class="ratio">2.75</td><td class="ratio">63.6%</td></tr>
<tr><td class="cpattern">(?:ba|lu|ro)+(r|ck)*</td><td class="time">240</td><td class="time">80</td><td class="ratio">3.00</td><td class="ratio">66.7%</td></tr>
<tr><td class="cpattern">\w+our\w*</td><td class="time">2020</td><td class="time">360</td><td class="ratio">5.61</td><td class="ratio">82.2%</td></tr>
<tr><td class="pattern">(?:^\w+$)|\b(\W)\1+\b</td><td class="time">2060</td><td class="time">340</td><td class="ratio">6.06</td><td class="ratio">83.5%</td></tr>
<tr><td class="cpattern">"[A-Z][a-z]*(?:(?:[,\s]|\R)(\s|\R)*[a-z]+){0,4}?[.!]"</td><td class="time">80</td><td class="time">40</td><td class="ratio">2.00</td><td class="ratio">50.0%</td></tr>
<tr><td class="pattern">\b(?:(?=\w+ro\w+)(?=\w+th\w+)\w+hr\w+)\b</td><td class="time">1340</td><td class="time">300</td><td class="ratio">4.47</td><td class="ratio">77.6%</td></tr>
<tr><td class="pattern">\b(?(?=\w+sh)\w+a|\w+uo)\w+\b</td><td class="time">2060</td><td class="time">360</td><td class="ratio">5.72</td><td class="ratio">82.5%</td></tr>
<tr><td class="cpattern">\b\WX{0,3}(?:(?:V?I{1,3})|V|IV|IX)\W\b</td><td class="time">940</td><td class="time">160</td><td class="ratio">5.88</td><td class="ratio">83.0%</td></tr>
<tr><td class="pattern">((\w)+?)\.\b(\s)*?\w</td><td class="time">5660</td><td class="time">520</td><td class="ratio">10.88</td><td class="ratio">90.8%</td></tr>
<tr><td class="pattern">(.{1,3})(\w*?\1)(?2)</td><td class="time">7200</td><td class="time">1620</td><td class="ratio">4.44</td><td class="ratio">77.5%</td></tr>
<tr><td class="pattern">-?-?-?-?-?-?-?-?-?-?-?-----------$</td><td class="time">680</td><td class="time">100</td><td class="ratio">6.80</td><td class="ratio">85.3%</td></tr>
<tr><td class="separator"></td><td class="separator"></td><td class="separator"></td><td class="separator"></td><td class="separator"></td></tr>
<tr><td class="pattern">Average:</td><td class="time">1461</td><td class="time">265</td><td class="ratio">4.57</td><td class="ratio">72.4%</td></tr>
</table>
<center><b>Non-utf8 input on a 64 bit x86 machine.</b></center>
<br>
<table class="results" width="100%" border="1">
<tr><th>Pattern</th><th>Int.<br>(ms)</th><th>JIT<br>(ms)</th><th>Runtime<br>ratio</th><th>Runtime<br>save %</th></tr>
<tr><td class="pattern">die der</td><td class="time">10</td><td class="time">10</td><td class="ratio">1.00</td><td class="ratio"> 0.0%</td></tr>
<tr><td class="cpattern">ist|der|die|und</td><td class="time">100</td><td class="time">20</td><td class="ratio">5.00</td><td class="ratio">80.0%</td></tr>
<tr><td class="pattern">\b\w+\b</td><td class="time">220</td><td class="time">140</td><td class="ratio">1.57</td><td class="ratio">36.4%</td></tr>
<tr><td class="cpattern">(?:da|ge|om)+(?:n|me)*</td><td class="time">60</td><td class="time">20</td><td class="ratio">3.00</td><td class="ratio">66.7%</td></tr>
<tr><td class="pattern">\b(?(?=\w+ro)\w+pa|\w+lle)\w+\b</td><td class="time">560</td><td class="time">300</td><td class="ratio">1.87</td><td class="ratio">46.4%</td></tr>
<tr><td class="pattern">\b(\W)\1+\b|(^(?=.*kl)(?=.*no).{15,40}$)</td><td class="time">680</td><td class="time">200</td><td class="ratio">3.40</td><td class="ratio">70.6%</td></tr>
<tr><td class="pattern">^.{4,32}(\P{N})\1{2,}.{4,32}(?&lt;![nuk])$</td><td class="time">240</td><td class="time">60</td><td class="ratio">4.00</td><td class="ratio">75.0%</td></tr>
<tr><td class="cpattern">^(\w{3,})(?!\1).*\h.*\1$</td><td class="time">5000</td><td class="time">2180</td><td class="ratio">2.29</td><td class="ratio">56.4%</td></tr>
<tr><td class="cpattern">((\w{2,8},?(\P{Z}|\R)){1,2}\.\s?)$</td><td class="time">4320</td><td class="time">1380</td><td class="ratio">3.13</td><td class="ratio">68.1%</td></tr>
<tr><td class="pattern">\b\w*?((.){1,3}\w*\2)\w*?(?1)</td><td class="time">1720</td><td class="time">700</td><td class="ratio">2.46</td><td class="ratio">59.3%</td></tr>
<tr><td class="pattern">\w*?(b{2,3})\w*?c</td><td class="time">1120</td><td class="time">400</td><td class="ratio">2.80</td><td class="ratio">64.3%</td></tr>
<tr><td class="pattern">\P{Lu}\P{L&amp;}{0,12}[\s\-]{1,4}..[\P{L}\P{N}]{4}</td><td class="time">300</td><td class="time">100</td><td class="ratio">3.00</td><td class="ratio">66.7%</td></tr>
<tr><td class="pattern">\b(\B([c-h])\B|[a-z]+?(?1)[a-z])</td><td class="time">900</td><td class="time">280</td><td class="ratio">3.21</td><td class="ratio">68.9%</td></tr>
<tr><td class="separator"></td><td class="separator"></td><td class="separator"></td><td class="separator"></td><td class="separator"></td></tr>
<tr><td class="pattern">Average:</td><td class="time">1172</td><td class="time">446</td><td class="ratio">2.83</td><td class="ratio">58.4%</td></tr>
</table>
<center><b>Utf8 input on a 32 bit x86 machine.</b></center>
<br>
<table class="results" width="100%" border="1">
<tr><th>Pattern</th><th>Int.<br>(ms)</th><th>JIT<br>(ms)</th><th>Runtime<br>ratio</th><th>Runtime<br>save %</th></tr>
<tr><td class="pattern">die der</td><td class="time">10</td><td class="time">10</td><td class="ratio">1.00</td><td class="ratio"> 0.0%</td></tr>
<tr><td class="cpattern">ist|der|die|und</td><td class="time">100</td><td class="time">30</td><td class="ratio">3.33</td><td class="ratio">70.0%</td></tr>
<tr><td class="pattern">\b\w+\b</td><td class="time">220</td><td class="time">110</td><td class="ratio">2.00</td><td class="ratio">50.0%</td></tr>
<tr><td class="cpattern">(?:da|ge|om)+(?:n|me)*</td><td class="time">80</td><td class="time">20</td><td class="ratio">4.00</td><td class="ratio">75.0%</td></tr>
<tr><td class="pattern">\b(?(?=\w+ro)\w+pa|\w+lle)\w+\b</td><td class="time">540</td><td class="time">230</td><td class="ratio">2.35</td><td class="ratio">57.4%</td></tr>
<tr><td class="pattern">\b(\W)\1+\b|(^(?=.*kl)(?=.*no).{15,40}$)</td><td class="time">640</td><td class="time">170</td><td class="ratio">3.76</td><td class="ratio">73.4%</td></tr>
<tr><td class="pattern">^.{4,32}(\P{N})\1{2,}.{4,32}(?&lt;![nuk])$</td><td class="time">200</td><td class="time">50</td><td class="ratio">4.00</td><td class="ratio">75.0%</td></tr>
<tr><td class="cpattern">^(\w{3,})(?!\1).*\h.*\1$</td><td class="time">4140</td><td class="time">1710</td><td class="ratio">2.42</td><td class="ratio">58.7%</td></tr>
<tr><td class="cpattern">((\w{2,8},?(\P{Z}|\R)){1,2}\.\s?)$</td><td class="time">4090</td><td class="time">1080</td><td class="ratio">3.79</td><td class="ratio">73.6%</td></tr>
<tr><td class="pattern">\b\w*?((.){1,3}\w*\2)\w*?(?1)</td><td class="time">1490</td><td class="time">550</td><td class="ratio">2.71</td><td class="ratio">63.1%</td></tr>
<tr><td class="pattern">\w*?(b{2,3})\w*?c</td><td class="time">1130</td><td class="time">290</td><td class="ratio">3.90</td><td class="ratio">74.3%</td></tr>
<tr><td class="pattern">\P{Lu}\P{L&amp;}{0,12}[\s\-]{1,4}..[\P{L}\P{N}]{4}</td><td class="time">270</td><td class="time">80</td><td class="ratio">3.38</td><td class="ratio">70.4%</td></tr>
<tr><td class="pattern">\b(\B([c-h])\B|[a-z]+?(?1)[a-z])</td><td class="time">750</td><td class="time">240</td><td class="ratio">3.12</td><td class="ratio">68.0%</td></tr>
<tr><td class="separator"></td><td class="separator"></td><td class="separator"></td><td class="separator"></td><td class="separator"></td></tr>
<tr><td class="pattern">Average:</td><td class="time">1050</td><td class="time">351</td><td class="ratio">3.06</td><td class="ratio">62.2%</td></tr>
</table>
<center><b>Utf8 input on a 64 bit x86 machine.</b></center>

<h3>Conclusion</h3>

JIT compiling is a powerful technology, which is able to speed up interpreted execution
including Java, JavaScript, ActionScript (with NanoJIT) or regular expression engines.

<h3>Contribution</h3>

I would like to encourage all of you to join the PCRE Performance Project, and
make PCRE faster than ever. My email address is hzmester (at) freemail (dot) hu.

<h3>Special thanks</h3>

First and foremost, the author thanks Philip Hazel for his continual help and support.<br>
<br>
Sorted as familiy name in alphabetic order:
<table border ="0" cellpadding="2">
<tr><td width="5%"></td>
<td>Giuseppe D'Angelo</td><td>-</td><td>QRegularExpression in <a href="http://qt-project.org/">Qt 5</a> and above.</td>
</tr>
<tr><td width="5%"></td>
<td>Victor Julien</td><td>-</td><td>Suricata project (<a href="http://www.openinfosecfoundation.org/">http://www.openinfosecfoundation.org/</a>).</td>
</tr>
<tr><td width="5%"></td>
<td>Sheri Pierce</td><td>-</td><td>Testing and feedback.</td>
</tr>
<tr><td width="5%"></td>
<td>Petr Pisar</td><td></td><td></td>
</tr>
</table>
<br>

<table width="100%" cellspacing=0 cellpadding=0>
<tr><td align=right>Last modification: 09.07.2014</td></tr></table>

</td><td width=20 class="main"></td></tr>
<tr height=20><td width=20 class="main"></td><td width=720 class="main"></td><td width=20 class="main"></td></tr>
</table>
</center>

</body>
</html>
